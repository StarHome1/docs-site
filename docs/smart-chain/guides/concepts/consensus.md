# Consensus Engine of Binance Smart Chain

## Abstract
We target to design the consensus engine of BSC(Binance Smart Chain) to achieve the following goals:

1. With quite a few blocks to confirm(should be less than Ethereum), better no fork in most cases.
2. Blocking time should be faster than Ethereum, i.e. 5 seconds or less.
3. No inflation, the block reward is transactiongas fees.
4. As much as compatible as Ethereum.
5. With governance as powerful as cosmos.

[Geth](https://github.com/ethereum/go-ethereum/wiki/geth) implements two kinds of consensus engine: ethash(based on PoW) and [clique](https://ethereum-magicians.org/t/eip-225-clique-proof-of-authority-consensus-protocol/1853)(base on PoA). Ethash is obviously not a good option for BSC because of lacking hash power on BSC. Clique has smaller blocking time and is invulnerable to 51% attack while doing as little to the core data structure as possible to preserve existing Ethereum client compatibility,  it seems to be a good choice except for its lack of powerful staking and governance capability on-chainon.  On the other hand, the Binance chain is built on cosmos-SDK which does have a perfect staking and governance mechanism. Naturally, we try to propose a consensus engine that:

* Binance chain does the staking and governance parts for BSC.
* ValidatorSet change of BSC is updated through interchain communication.
* Consensus engine of BSC keeps as simple as clique.

There are already some popular implementations of PoA consensus, like [Bor](https://blog.matic.network/heimdall-and-bor-matic-validator-and-block-production-layers/).


## Consensus Protocol

The framework of consensus engine is quite similar to [clique](https://ethereum-magicians.org/t/eip-225-clique-proof-of-authority-consensus-protocol/1853). This doc will focus more on the difference and ignore the common details. The key features are:

1. Validators set changes at the (epoch+N/2) blocks. (N is the size of validatorset before epoch block). Considering the security of light client, we delay N/2 block to let validatorSet change take place.
   The key interfaces of an engine are: `VerifyHeader`, `VerifySeal`, `FinalizeAndAssemble`, `Prepare` and `Seal`.

### How to Produce a new block

#### Step 1: Prepare
A validator node prepares the block header of next block.
* Load snapshot from cache or database,
		* If (height % epoch)==0, should fetch ValidatorSet from `BSCValidatorSet` [contract](https://explorer.binance.org/smart-testnet/address/0x0000000000000000000000000000000000001000/transactions).
*  Every epoch block, will store validators set message in `extraData` field of block header to facilitate the implement of light client.
* The coinbase is the address of the validator

#### Step2: FinalizeAndAssemble

* If the validator is not inturn validator, will call slash contract to slash the expected validator and generate a slashing transaction.
* If there is gas-fee in the block, will distribute **1/16** to system reward contract, the rest go to validator contract.

#### Step3: Seal
The final step before a validator broadcast the new block.
* Sign all things and append the signature to extraData.
* If it is out of turn for validators to sign blocks, an honest validator it will wait for a reasonable time.

### How to Validate/Replay a block

#### Step1: VerifyHeader
Verify the block header when receiving a new block.

* Verify the signature of the coinbase is in `extraData` of the `blockheader`
* Compare the block time of the `blockHeader` and the expected block time that the signer suppose to use, will deny a `blockerHeader` that is smaller than expected. It helps to prevent a selfish validator from rushing to seal a block.
* The `coinbase` should be the signer and the difficulty should be expected value.

#### Step2: Finalize

* If it is an epoch block, a validator node will fetch validatorSet from BSCValidatorSet and compare it with extra_data.
* If the block is not generate by inturn validatorvalidaror, will call slash contract.
if there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract.
* The transaction generated by the consensus engine must be the same as the tx in block.

### Signature
The signature of the coinbase is in extraData of the blockheader, the structure of extraData is:
epoch block. 32 bytes of extraVanity + N*{20 bytes of validator address} + 65 bytes of signature.
none epoch block. 32 bytes of extraVanity + 65 bytes of signature.
The signed content is the `Keccak256` of RLP encoded of the block header.
